<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Family History Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <!-- Arrowheads -->
  <script src="https://unpkg.com/leaflet-arrowheads@1.3.1/src/leaflet-arrowheads.js"></script>
  <style>
    :root {
      --pad: clamp(8px, 2.5vw, 14px);
      --card: white;
      --shadow: 0 6px 18px rgba(0,0,0,.15);
      --thumb-size: 44px; /* mobile thumb target */
    }
    html, body, #map { height: 100%; margin: 0; }
    #map { touch-action: pan-x pan-y; }

    /* Zoom to top-right, away from sidebar */
    .leaflet-top.leaflet-right { 
      margin-top: calc(env(safe-area-inset-top, 0px) + var(--pad));
      margin-right: calc(env(safe-area-inset-right, 0px) + var(--pad));
    }
    .leaflet-control-zoom a { width: var(--thumb-size); height: var(--thumb-size); line-height: var(--thumb-size); font-size: 20px; }

    #navToggle {
      position: absolute; z-index: 1100; top: calc(env(safe-area-inset-top,0px) + var(--pad)); left: calc(env(safe-area-inset-left,0px) + var(--pad));
      background: var(--card); border: none; padding: 8px 12px;
      border-radius: 10px; box-shadow: var(--shadow);
      font-size: 20px; cursor: pointer;
    }
    @media (min-width: 768px) { #navToggle { display:none; } }

    .sidebar {
      position: absolute; z-index: 1000; top: calc(env(safe-area-inset-top,0px) + var(--pad)); left: calc(env(safe-area-inset-left,0px) + var(--pad));
      background: var(--card); padding: 12px; border-radius: 12px;
      box-shadow: var(--shadow); max-width: min(380px, 92vw); font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    @media (max-width: 767px) {
      .sidebar { transform: translateX(-110%); transition: transform .28s ease; }
      .sidebar.sidebar--open { transform: translateX(0); }
    }

    .legend { margin-top: 8px; font-size: 13px; }
    .legend div { margin: 4px 0; display:flex; align-items:center; gap:6px; }
    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #3333; }
    .dim { color:#666 }
    .chip { display:inline-block; padding:6px 10px; border-radius:16px; background:#eee; margin:2px; cursor:pointer; user-select:none; }
    .chip.active { background:#ddd; }
    #layerToggles label { display:inline-flex; align-items:center; gap:6px; padding:6px 8px; border-radius:10px; background:#f4f4f4; margin-right:6px; margin-bottom:6px; }
    #layerToggles input { width:18px; height:18px; }

    /* Optional labels */
    .map-label { 
      background: rgba(255,255,255,.85);
      padding: 2px 6px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,.12);
      font-size: 12px; border: 1px solid #0001;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <button id="navToggle" aria-controls="sidebar" aria-expanded="false">☰</button>

  <div id="sidebar" class="sidebar" role="dialog" aria-label="Map controls">
    <div><input id="searchInput" type="text" placeholder="Search…" style="width:100%; height:40px; padding:0 10px; border-radius:8px; border:1px solid #ddd;" /></div>

    <div style="margin-top:10px;">
      <label>Years: <span id="yearLabel"></span></label>
      <div style="display:flex; gap:8px;">
        <input type="range" id="yearStart" min="1600" max="2020" value="1600" style="flex:1;">
        <input type="range" id="yearEnd"   min="1600" max="2020" value="2020" style="flex:1;">
      </div>
    </div>

    <div id="layerToggles" style="margin-top:10px; display:flex; flex-wrap:wrap; gap:4px;">
      <label><input type="checkbox" data-layer="People" checked> People</label>
      <label><input type="checkbox" data-layer="Places" checked> Places</label>
      <label><input type="checkbox" data-layer="Events"> Events</label>
      <label><input type="checkbox" data-layer="Birth Points" checked> Births</label>
      <label><input type="checkbox" data-layer="Death Points" checked> Deaths</label>
      <label><input type="checkbox" id="labelsToggle"> Labels</label>
    </div>

    <div id="eraChips" style="margin-top:8px;"></div>

    <div id="presets" style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
      <button data-range="1600-2020" data-layers="People,Places,Events,Birth Points,Death Points" style="padding:8px 10px;border-radius:10px;border:1px solid #ddd;cursor:pointer;background:#fafafa;">All</button>
      <button data-range="1800-1900" data-layers="People" style="padding:8px 10px;border-radius:10px;border:1px solid #ddd;cursor:pointer;background:#fafafa;">People 1800–1900</button>
    </div>

    <div id="updated" class="legend dim">Loading…</div>
    <div id="eraLegend" class="legend"></div>
  </div>

  <script>
  // ---------- CONFIG ----------
  const DATA = "data/";

  // Tweak this if your line file is already death->birth
  const LINES_FILE_IS_BIRTH_TO_DEATH = true;

  // Colors / sizes
  const STYLE = {
    people:  { base: 6, color: "#0A84FF" },
    places:  { base: 6, color: "#2ed573" },
    births:  { base: 6, color: "#1f77ff" },
    deaths:  { base: 6, color: "#e43f3f" },
    events:  { color: "#ff6b6b", weight: 2, opacity: 0.9 },
    lines:   { weight: 3.5, opacity: 0.95 },
    // Era colors
    eraColors: {
      "Colonial Era": "#5cb85c",
      "Early Republic": "#d9534f",
      "Civil War & Reconstruction": "#5bc0de",
      "Gilded Age": "#f0ad4e",
      "Progressive Era & WWI": "#337ab7",
      "Roaring 20s & Great Depression": "#8e44ad"
    }
  };

  // Popup fields (null => all)
  const FIELDS = {
    people: [
      ["primary_name","Name"],["sex","Sex"],["birth_year","Birth Year"],["death_year","Death Year"],
      ["birth_place_name","Birth Place"],["death_place_name","Death Place"],["residence","Residence"]
    ],
    places: [["place_name","Place"],["place_type","Type"],["country","Country"],["state","State"],["county","County"]],
    events: [["event_type","Type"],["event_year","Year"],["description","Description"]],
    births: [["primary_name","Name"],["birth_year","Birth Year"],["birth_place_name","Birth Place"]],
    deaths: [["primary_name","Name"],["death_year","Death Year"],["death_place_name","Death Place"]],
    lines:  [["primary_name","Name"],["era","Era"],["birth_year","Birth Year"],["death_year","Death Year"]]
  };

  // ---------- Helpers ----------
  const canvasRenderer = L.canvas({ padding: 0.5, tolerance: 10 }); // bigger line touch area

  function loadJson(url) {
    return fetch(url).then(r => {
      if (!r.ok) throw new Error(`${r.status} ${r.statusText} – ${url}`);
      return r.json();
    });
  }

  function popupTable(props, fieldList=null) {
    const entries = fieldList
      ? fieldList.filter(([k]) => props[k] != null && props[k] !== "")
                .map(([k,label]) => [label, props[k]])
      : Object.entries(props).filter(([k,v]) => v != null && v !== "" && typeof v !== "object");
    const rows = entries.map(([k,v]) =>
      `<tr><th style="text-align:left; padding-right:.5rem; white-space:nowrap;">${k}</th><td>${v}</td></tr>`).join("");
    return `<table>${rows}</table>`;
  }

  const eraColor = era => STYLE.eraColors[era] || "#3742fa";

  // Scale point radius with zoom; keep nice on mobile
  function scaledRadius(base) {
    const z = map.getZoom();
    const r = base + Math.max(0, (z - 5)) * 0.8; // grows after z5
    return Math.max(6, Math.min(r, 18));
  }

  function arrowSizeForZoom() {
    const z = map.getZoom();
    return Math.round(Math.max(10, Math.min(28, 6 + (z * 2))));
  }

  // Reverse a LineString/MultiLineString coordinates
  function reversedGeometry(geom) {
    if (!geom) return geom;
    const clone = JSON.parse(JSON.stringify(geom));
    if (clone.type === "LineString") {
      clone.coordinates.reverse();
    } else if (clone.type === "MultiLineString") {
      clone.coordinates = clone.coordinates.map(arr => arr.slice().reverse());
    }
    return clone;
  }

  // ---------- Map ----------
  const map = L.map("map", {
    preferCanvas: true,
    zoomControl: false,
    tapTolerance: 25,
    wheelDebounceTime: 35
  }).setView([41.9, -87.65], 5);

  L.control.zoom({ position: 'topright' }).addTo(map);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // UI refs
  const sidebarEl = document.getElementById('sidebar');
  const navToggle  = document.getElementById('navToggle');
  navToggle.addEventListener('click', () => {
    const open = sidebarEl.classList.toggle('sidebar--open');
    navToggle.setAttribute('aria-expanded', open);
  });

  const yearStartEl = document.getElementById('yearStart');
  const yearEndEl   = document.getElementById('yearEnd');
  const yearLabelEl = document.getElementById('yearLabel');
  const labelsToggleEl = document.getElementById('labelsToggle');
  function updateYearLabel(){ yearLabelEl.textContent = `${yearStartEl.value} - ${yearEndEl.value}`; }
  function currentYearRange(){ return [+yearStartEl.value, +yearEndEl.value]; }
  updateYearLabel();

  const overlays = {};
  const searchIndex = [];
  const yearFilters = [];

  function addOverlay(layer, name, addNow=true) {
    overlays[name] = layer;
    const toggle = document.querySelector(`input[data-layer='${name}']`);
    const update = () => {
      if (!toggle || toggle.checked) map.addLayer(layer); else map.removeLayer(layer);
      fitIfNeededSoon();
    };
    if (toggle) toggle.addEventListener('change', update);
    if (addNow) update();
  }

  function doSearch(q) {
    q = q.trim().toLowerCase();
    if (!q) return;
    const match = searchIndex.find(({feature}) =>
      Object.values(feature.properties || {}).some(v => String(v).toLowerCase().includes(q))
    );
    if (match) {
      const tmp = L.geoJSON(match.feature);
      tmp.bindPopup(popupTable(match.feature.properties || {}, FIELDS[match.field]));
      tmp.addTo(map);
      map.fitBounds(tmp.getBounds().pad(0.25));
      tmp.openPopup();
      setTimeout(() => map.removeLayer(tmp), 5000);
    }
  }
  const searchInputEl = document.getElementById('searchInput');
  searchInputEl.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); doSearch(e.target.value); }});
  searchInputEl.addEventListener('change', e => doSearch(e.target.value));

  // Presets
  document.querySelectorAll('#presets button').forEach(btn => {
    btn.addEventListener('click', () => {
      const layers = (btn.dataset.layers || '').split(',').map(s => s.trim()).filter(Boolean);
      document.querySelectorAll('input[data-layer]').forEach(cb => { cb.checked = layers.includes(cb.dataset.layer); cb.dispatchEvent(new Event('change')); });
      if (btn.dataset.range) {
        const [s,e] = btn.dataset.range.split('-').map(Number);
        yearStartEl.value = s; yearEndEl.value = e; filterByYear();
      }
    });
  });

  // Data last updated
  fetch(DATA + "places.geojson", { method: "HEAD" })
    .then(r => {
      const d = r.headers.get("last-modified");
      document.getElementById("updated").textContent = d ? `Data last updated: ${new Date(d).toLocaleString()}` : "";
    }).catch(() => {});

  // ---------- Layers ----------
  function filterByYear() {
    updateYearLabel();
    const [start, end] = currentYearRange();
    yearFilters.forEach(fn => fn(start, end));
  }
  yearStartEl.addEventListener('input', filterByYear);
  yearEndEl.addEventListener('input', filterByYear);

  // People (clustered)
  loadJson(DATA + "people.geojson").then(data => {
    const cluster = L.markerClusterGroup({
      showCoverageOnHover: false,
      spiderfyOnMaxZoom: true,
      spiderfyDistanceMultiplier: 1.5,
      maxClusterRadius: 60,
      disableClusteringAtZoom: 11
    });

    const layer = L.geoJSON(null, {
      pointToLayer: (f, latlng) => L.circleMarker(latlng, {
        radius: scaledRadius(STYLE.people.base),
        color: STYLE.people.color,
        weight: 2, fillOpacity: .9, opacity: 1
      }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.people))
    });

    const render = (start, end) => {
      layer.clearLayers();
      const feats = (data.features || []).filter(f => {
        const p = f.properties || {};
        const y = p.birth_year || p.death_year;
        return !y || (y >= start && y <= end);
      });
      layer.addData(feats);
      cluster.clearLayers();
      cluster.addLayer(layer);
    };

    map.on('zoomend', () => {
      layer.eachLayer(m => { if (m.setStyle) m.setStyle({ radius: scaledRadius(STYLE.people.base) }); });
    });

    yearFilters.push(render);
    render(...currentYearRange());
    addOverlay(cluster, "People");
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'people' }));
  });

  // Places
  let placeTooltips = [];
  loadJson(DATA + "places.geojson").then(data => {
    const layer = L.geoJSON(null, {
      pointToLayer: (f, latlng) => L.circleMarker(latlng, {
        radius: scaledRadius(STYLE.places.base),
        color: STYLE.places.color, weight: 2, fillOpacity: .75
      }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.places))
    });

    const enableLabels = () => {
      disableLabels();
      if (!labelsToggleEl.checked || map.getZoom() < 8) return;
      layer.eachLayer(l => {
        const name = l.feature?.properties?.place_name || l.feature?.properties?.name;
        if (!name) return;
        const t = l.bindTooltip(name, { permanent: true, direction: 'top', className: 'map-label', offset: [0,-8] }).openTooltip();
        placeTooltips.push(t);
      });
    };
    const disableLabels = () => {
      placeTooltips.forEach(t => t.unbindTooltip && t.unbindTooltip());
      placeTooltips = [];
      layer.eachLayer(l => l.unbindTooltip && l.unbindTooltip());
    };
    labelsToggleEl.addEventListener('change', enableLabels);
    map.on('zoomend', enableLabels);

    const render = () => { /* places are not time-filtered by default */ };
    yearFilters.push(render);

    layer.addData(data);
    addOverlay(layer, "Places");
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'places' }));

    // resize on zoom
    map.on('zoomend', () => {
      layer.eachLayer(m => m.setStyle && m.setStyle({ radius: scaledRadius(STYLE.places.base) }));
    });
  });

  // Events
  loadJson(DATA + "events.geojson").then(data => {
    const layer = L.geoJSON([], {
      pointToLayer: (f, latlng) => L.circleMarker(latlng, { radius: 6, color: "#b30000", weight: 2, fillOpacity: .9 }),
      style: () => ({ ...STYLE.events }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.events))
    });
    const render = (start, end) => {
      layer.clearLayers();
      const feats = (data.features || []).filter(f => {
        const y = (f.properties || {}).event_year;
        return !y || (y >= start && y <= end);
      });
      layer.addData(feats);
    };
    yearFilters.push(render);
    render(...currentYearRange());
    addOverlay(layer, "Events", false);
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'events' }));
  });

  // Birth points
  let birthTooltips = [];
  loadJson(DATA + "birth_location_points.geojson").then(data => {
    const layer = L.geoJSON([], {
      pointToLayer: (f, latlng) => L.circleMarker(latlng, {
        radius: scaledRadius(STYLE.births.base),
        color: STYLE.births.color, weight: 2, fillOpacity: .95
      }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.births))
    });
    const render = (start, end) => {
      layer.clearLayers();
      const feats = (data.features || []).filter(f => {
        const y = (f.properties || {}).birth_year;
        return !y || (y >= start && y <= end);
      });
      layer.addData(feats);
    };
    yearFilters.push(render);
    render(...currentYearRange());
    addOverlay(layer, "Birth Points");
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'births' }));

    map.on('zoomend', () => layer.eachLayer(m => m.setStyle && m.setStyle({ radius: scaledRadius(STYLE.births.base) })));

    // labels
    const updateLabels = () => {
      layer.eachLayer(l => l.unbindTooltip && l.unbindTooltip());
      if (!labelsToggleEl.checked || map.getZoom() < 8) return;
      layer.eachLayer(l => {
        const name = l.feature?.properties?.primary_name;
        if (name) l.bindTooltip(name, { permanent:true, direction:'top', className:'map-label', offset:[0,-8] }).openTooltip();
      });
    };
    labelsToggleEl.addEventListener('change', updateLabels);
    map.on('zoomend', updateLabels);
  });

  // Death points
  loadJson(DATA + "death_location_points.geojson").then(data => {
    const layer = L.geoJSON([], {
      pointToLayer: (f, latlng) => L.circleMarker(latlng, {
        radius: scaledRadius(STYLE.deaths.base),
        color: STYLE.deaths.color, weight: 2, fillOpacity: .95
      }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.deaths))
    });
    const render = (start, end) => {
      layer.clearLayers();
      const feats = (data.features || []).filter(f => {
        const y = (f.properties || {}).death_year;
        return !y || (y >= start && y <= end);
      });
      layer.addData(feats);
    };
    yearFilters.push(render);
    render(...currentYearRange());
    addOverlay(layer, "Death Points");
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'deaths' }));

    map.on('zoomend', () => layer.eachLayer(m => m.setStyle && m.setStyle({ radius: scaledRadius(STYLE.deaths.base) })));

    // labels
    const updateLabels = () => {
      layer.eachLayer(l => l.unbindTooltip && l.unbindTooltip());
      if (!labelsToggleEl.checked || map.getZoom() < 8) return;
      layer.eachLayer(l => {
        const name = l.feature?.properties?.primary_name;
        if (name) l.bindTooltip(name, { permanent:true, direction:'top', className:'map-label', offset:[0,-8] }).openTooltip();
      });
    };
    labelsToggleEl.addEventListener('change', updateLabels);
    map.on('zoomend', updateLabels);
  });

  // Birth→Death Lines by Era (rendered as Death→Birth, arrow at end)
  let arrowLayers = []; // track for zoom-resizing
  loadJson(DATA + "birth_to_death_lines_eras.geojson").then(data => {
    const eras = Array.from(new Set((data.features || []).map(f => (f.properties || {}).era).filter(Boolean))).sort();
    const lineLayers = {};
    const ERA_GROUPS = {};

    eras.forEach(era => {
      const group = L.layerGroup([], { renderer: canvasRenderer });
      ERA_GROUPS[era] = group;
      lineLayers[era] = L.geoJSON([], {
        renderer: canvasRenderer,
        style: () => ({ color: eraColor(era), weight: STYLE.lines.weight, opacity: STYLE.lines.opacity, lineCap: 'round', lineJoin:'round' }),
        onEachFeature: (f, l) => {
          l.bindPopup(popupTable(f.properties || {}, FIELDS.lines));
          // Invisible, fat hit-area on top for easier tapping
          const hit = L.polyline(l.getLatLngs(), {
            renderer: canvasRenderer,
            color: '#000', weight: 18, opacity: 0, interactive: true
          }).on('click', () => l.openPopup());
          group.addLayer(l);
          group.addLayer(hit);
          arrowLayers.push(l);
        }
      });
      group.addLayer(lineLayers[era]);
      addOverlay(group, `Lines: ${era}`);
    });

    function featureToDeathBirth(f) {
      const g = f.geometry;
      if (!g) return f;
      if (LINES_FILE_IS_BIRTH_TO_DEATH) {
        // Force reverse: we want death → birth direction
        const newGeom = reversedGeometry(g);
        return { ...f, geometry: newGeom };
      }
      return f;
    }

    const render = (start, end) => {
      eras.forEach(era => {
        const layer = lineLayers[era];
        layer.clearLayers();
        const feats = (data.features || []).filter(f => {
          const p = f.properties || {};
          const y = p.birth_year || p.death_year;
          return p.era === era && (!y || (y >= start && y <= end));
        }).map(featureToDeathBirth);
        layer.addData(feats);

        // Add arrowheads pointing from death → birth (end of the line)
        const size = arrowSizeForZoom() + 'px';
        ERA_GROUPS[era].eachLayer(l => {
          if (l.arrowheads) l.arrowheads({ frequency: 'end', size, fill: true, offsets: { end: '10px' }});
        });
      });
    };

    yearFilters.push(render);
    render(...currentYearRange());

    // era chips
    const chipContainer = document.getElementById('eraChips');
    eras.forEach(era => {
      const chip = document.createElement('span');
      chip.textContent = era;
      chip.className = 'chip active';
      const layerName = `Lines: ${era}`;
      chip.dataset.layer = layerName;
      chip.style.background = eraColor(era);
      chip.style.color = '#fff';
      chip.addEventListener('click', () => {
        chip.classList.toggle('active');
        const layer = overlays[layerName];
        if (chip.classList.contains('active')) map.addLayer(layer); else map.removeLayer(layer);
        fitIfNeededSoon();
      });
      chipContainer.appendChild(chip);
    });

    // legend
    const legendEl = document.getElementById("eraLegend");
    legendEl.innerHTML = "<b>Death → Birth Lines (by Era)</b>" +
      Object.entries(STYLE.eraColors).map(([label, col]) => `<div><span class="swatch" style="background:${col}"></span> ${label}</div>`).join("");

    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'lines' }));

    // Resize arrows on zoom for better readability
    map.on('zoomend', () => {
      const size = arrowSizeForZoom() + 'px';
      eras.forEach(era => {
        ERA_GROUPS[era].eachLayer(l => {
          if (l.arrowheads) l.arrowheads({ frequency: 'end', size, fill: true, offsets: { end: '10px' }});
        });
      });
    });
  });

  // Fit map to visible layers once (and lightly debounce)
  let fitted = false;
  let fitTimer = null;
  function fitIfNeeded() {
    if (fitted) return;
    let bounds = null;
    for (const layer of Object.values(overlays)) {
      if (!map.hasLayer(layer)) continue;
      try {
        const b = layer.getBounds ? layer.getBounds() : L.featureGroup([layer]).getBounds();
        if (b && b.isValid()) bounds = bounds ? bounds.extend(b) : b;
      } catch {}
    }
    if (bounds && bounds.isValid()) {
      map.fitBounds(bounds.pad(0.15));
      fitted = true;
    }
  }
  function fitIfNeededSoon() {
    clearTimeout(fitTimer);
    fitTimer = setTimeout(fitIfNeeded, 120);
  }
  </script>
</body>
</html>


