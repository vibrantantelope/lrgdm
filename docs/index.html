<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Family History Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet CSS/JS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <!-- Optional: MarkerCluster for dense points -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
  />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    .sidebar {
      position: absolute; z-index: 1000; top: 10px; left: 10px;
      background: white; padding: 10px 12px; border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,.15); max-width: 320px; font: 14px/1.3 system-ui, sans-serif;
    }
    .legend { margin-top: 8px; font-size: 13px; }
    .legend div { margin: 4px 0; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="sidebar">
    <strong>Family History Map</strong>
    <div>Click points/lines to see details. Use the layer toggle (top-right).</div>
    <div id="updated" class="legend"></div>
  </div>

  <script>
    // --- Helpers (edit to your schema field names) ---
    function popupForPerson(p) {
      // Example fields: primary_name, birth_year, death_year, birth_place_name, death_place_name
      const name = p.primary_name || p.name || "Unknown";
      const b = p.birth_year ? `b. ${p.birth_year}` : "";
      const d = p.death_year ? `d. ${p.death_year}` : "";
      const life = (b || d) ? `(${[b, d].filter(Boolean).join(" – ")})` : "";
      const birthPlace = p.birth_place_name ? `<div><b>Birth place:</b> ${p.birth_place_name}</div>` : "";
      const deathPlace = p.death_place_name ? `<div><b>Death place:</b> ${p.death_place_name}</div>` : "";
      return `<div><b>${name}</b> ${life}</div>${birthPlace}${deathPlace}`;
    }

    function popupForPlace(p) {
      // Example fields: place_name, place_type, country / state / county...
      const name = p.place_name || p.name || "Place";
      const type = p.place_type ? ` (${p.place_type})` : "";
      return `<div><b>${name}${type}</b></div>`;
    }

    function popupForEvent(p) {
      // Example fields: event_type, event_year, description, pid_people
      const type = p.event_type || "Event";
      const year = p.event_year ? ` (${p.event_year})` : "";
      const desc = p.description ? `<div>${p.description}</div>` : "";
      return `<div><b>${type}${year}</b>${desc}</div>`;
    }

    // --- Map ---
    const map = L.map("map").setView([41.9, -87.65], 5);
    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const baseLayers = { "OpenStreetMap": osm };
    const overlays = {}; // filled below
    L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

    // Try to show "Data last updated" from file modified time (best-effort)
    fetch("data/places.geojson", { method: "HEAD" })
      .then(r => {
        const d = r.headers.get("last-modified");
        if (d) document.getElementById("updated").textContent = `Data last updated: ${new Date(d).toLocaleString()}`;
      }).catch(()=>{});

    // --- Styling ---
    const pointStyle = { radius: 6, weight: 1, color: "#333", fillOpacity: 0.8 };
    const lineStyle  = { color: "#3742fa", weight: 2, opacity: 0.8 };
    const eventStyle = { color: "#ff6b6b", weight: 2, opacity: 0.9 };

    // --- Load layers (adjust filenames if you renamed them) ---
    // People (points)
    fetch("data/people.geojson").then(r => r.json()).then(data => {
      const cluster = L.markerClusterGroup();
      const layer = L.geoJSON(data, {
        pointToLayer: (feat, latlng) => L.circleMarker(latlng, pointStyle),
        onEachFeature: (feat, layer) => layer.bindPopup(popupForPerson(feat.properties))
      });
      cluster.addLayer(layer);
      overlays["People"] = cluster;
      map.addLayer(cluster);
      fitIfNeeded();
    }).catch(()=>{});

    // Places (points or polygons)
    fetch("data/places.geojson").then(r => r.json()).then(data => {
      const layer = L.geoJSON(data, {
        pointToLayer: (feat, latlng) => L.circleMarker(latlng, { ...pointStyle, fillOpacity: 0.6 }),
        style: () => ({ color: "#2ed573", weight: 2, opacity: 0.8, fillOpacity: 0.2 }),
        onEachFeature: (feat, layer) => layer.bindPopup(popupForPlace(feat.properties))
      });
      overlays["Places"] = layer;
      map.addLayer(layer);
      fitIfNeeded();
    }).catch(()=>{});

    // PersonPlaces (lines connecting people↔places)
    fetch("data/person_places.geojson").then(r => r.json()).then(data => {
      const layer = L.geoJSON(data, {
        style: () => lineStyle,
        onEachFeature: (feat, layer) => {
          const p = feat.properties || {};
          const who = p.primary_name || p.pid_person || "Person";
          const what = p.link_type || "Link";
          const place = p.place_name || p.pid_place || "Place";
          layer.bindPopup(`<div><b>${who}</b> → ${what} → <b>${place}</b></div>`);
        }
      });
      overlays["Connections"] = layer;
      map.addLayer(layer);
      fitIfNeeded();
    }).catch(()=>{});

    // Events (points/lines/polys)
    fetch("data/events.geojson").then(r => r.json()).then(data => {
      const layer = L.geoJSON(data, {
        pointToLayer: (feat, latlng) => L.circleMarker(latlng, { ...pointStyle, color: "#b30000" }),
        style: () => eventStyle,
        onEachFeature: (feat, layer) => layer.bindPopup(popupForEvent(feat.properties))
      });
      overlays["Events"] = layer;
      map.addLayer(layer);
      fitIfNeeded();
    }).catch(()=>{});

    // Fit map to visible layers once (when first layers load)
    let fitted = false;
    function fitIfNeeded() {
      if (fitted) return;
      const group = L.featureGroup();
      Object.values(overlays).forEach(l => {
        if (map.hasLayer(l)) {
          // If it's a cluster group, gather child layers
          if (l.getLayers && l.getLayers().length) {
            l.getLayers().forEach(child => group.addLayer(child));
          } else {
            group.addLayer(l);
          }
        }
      });
      try {
        if (group.getLayers().length) {
          map.fitBounds(group.getBounds().pad(0.15));
          fitted = true;
        }
      } catch (e) {}
    }
  </script>
</body>
</html>
