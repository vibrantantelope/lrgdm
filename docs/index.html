<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Family History Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/leaflet-arrowheads@1.3.1/src/leaflet-arrowheads.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .sidebar {
      position: absolute; z-index: 1000; top: 10px; left: 10px;
      background: white; padding: 10px 12px; border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,.15); max-width: 360px; font: 14px/1.3 system-ui, sans-serif;
    }
    .legend { margin-top: 8px; font-size: 13px; }
    .legend div { margin: 4px 0; display:flex; align-items:center; gap:6px; }
    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #3333; }
    .dim { color:#666 }
    .chip { display:inline-block; padding:2px 6px; border-radius:12px; background:#eee; margin:2px; cursor:pointer; }
    .chip.active { background:#ddd; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="sidebar">
    <div><input id="searchInput" type="text" placeholder="Search…" style="width:100%" /></div>
    <div style="margin-top:6px;">
      <label>Years: <span id="yearLabel"></span></label>
      <div style="display:flex; gap:4px;">
        <input type="range" id="yearStart" min="1600" max="2020" value="1600" style="flex:1;">
        <input type="range" id="yearEnd" min="1600" max="2020" value="2020" style="flex:1;">
      </div>
    </div>
    <div id="layerToggles" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
      <label><input type="checkbox" data-layer="People" checked> People</label>
      <label><input type="checkbox" data-layer="Places" checked> Places</label>
      <label><input type="checkbox" data-layer="Events"> Events</label>
      <label><input type="checkbox" data-layer="Birth Points" checked> Births</label>
      <label><input type="checkbox" data-layer="Death Points" checked> Deaths</label>
    </div>
    <div id="eraChips" style="margin-top:8px;"></div>
    <div id="presets" style="margin-top:8px; display:flex; gap:4px; flex-wrap:wrap;">
      <button data-range="1600-2020" data-layers="People,Places,Events,Birth Points,Death Points">All</button>
      <button data-range="1800-1900" data-layers="People">People 1800-1900</button>
    </div>
    <div id="updated" class="legend dim">Loading…</div>
    <div id="eraLegend" class="legend"></div>
  </div>

  <script>
  // ---------- CONFIG ----------
  const DATA = "data/";

  // Colors / sizes in one place
  const STYLE = {
    people:  { radius: 6, color: "#0A84FF" },
    places:  { radius: 6, color: "#2ed573" },
    births:  { radius: 6, color: "#1f77ff" },
    deaths:  { radius: 6, color: "#e43f3f" },
    events:  { color: "#ff6b6b", weight: 2, opacity: 0.9 },
    lines:   { weight: 2.5, opacity: 0.95 },             // default for lines
    // Era-specific palette (edit freely)
    eraColors: {
      "Early Republic": "#d9534f",
      "Gilded Age": "#f0ad4e",
      "Colonial Era": "#5cb85c",
      "Civil War & Reconstruction": "#5bc0de",
      "Progressive Era & WWI": "#337ab7",
      "Roaring 20s & Great Depression": "#8e44ad"
    }
  };

  // Popup field lists (set to null to show ALL attributes)
  const FIELDS = {
    people: [
      ["primary_name","Name"],
      ["sex","Sex"],
      ["birth_year","Birth Year"],
      ["death_year","Death Year"],
      ["birth_place_name","Birth Place"],
      ["death_place_name","Death Place"],
      ["residence","Residence"]
    ],
    places: [
      ["place_name","Place"],
      ["place_type","Type"],
      ["country","Country"],
      ["state","State"], ["county","County"]
    ],
    events: [
      ["event_type","Type"], ["event_year","Year"], ["description","Description"]
    ],
    births: [
      ["primary_name","Name"], ["birth_year","Birth Year"], ["birth_place_name","Birth Place"]
    ],
    deaths: [
      ["primary_name","Name"], ["death_year","Death Year"], ["death_place_name","Death Place"]
    ],
    lines: [
      ["primary_name","Name"], ["era","Era"], ["birth_year","Birth Year"], ["death_year","Death Year"]
    ]
  };

  // ---------- Small helpers ----------
  function loadJson(url, onOk) {
    return fetch(url).then(r => {
      if (!r.ok) throw new Error(`${r.status} ${r.statusText} – ${url}`);
      return r.json();
    }).then(onOk).catch(err => console.error("Layer load failed:", err));
  }

  function popupTable(props, fieldList=null) {
    const entries = fieldList
      ? fieldList.filter(([k]) => props[k] != null && props[k] !== "")
                .map(([k,label]) => [label, props[k]])
      : Object.entries(props).filter(([k,v]) => v != null && v !== "" && typeof v !== "object");
    const rows = entries.map(([k,v]) =>
      `<tr><th style="text-align:left; padding-right:.5rem; white-space:nowrap;">${k}</th><td>${v}</td></tr>`).join("");
    return `<table>${rows}</table>`;
  }

  const eraColor = era => STYLE.eraColors[era] || "#3742fa";

  const searchIndex = [];
  const yearFilters = [];
  const yearStartEl = document.getElementById('yearStart');
  const yearEndEl = document.getElementById('yearEnd');
  const yearLabelEl = document.getElementById('yearLabel');
  function updateYearLabel() {
    yearLabelEl.textContent = `${yearStartEl.value} - ${yearEndEl.value}`;
  }
  function filterByYear() {
    updateYearLabel();
    const start = +yearStartEl.value;
    const end = +yearEndEl.value;
    yearFilters.forEach(fn => fn(start, end));
  }
  yearStartEl.addEventListener('input', filterByYear);
  yearEndEl.addEventListener('input', filterByYear);
  updateYearLabel();

  const map = L.map("map").setView([41.9, -87.65], 5);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const overlays = {};
  function addOverlay(layer, name, addNow=true) {
    overlays[name] = layer;
    const toggle = document.querySelector(`input[data-layer='${name}']`);
    const update = () => {
      if (!toggle || toggle.checked) {
        map.addLayer(layer);
      } else {
        map.removeLayer(layer);
      }
      fitIfNeeded();
    };
    if (toggle) toggle.addEventListener('change', update);
    if (addNow) update();
  }

  const searchInputEl = document.getElementById('searchInput');
  function doSearch(q) {
    q = q.trim().toLowerCase();
    if (!q) return;
    const match = searchIndex.find(({feature}) =>
      Object.values(feature.properties || {}).some(v => String(v).toLowerCase().includes(q))
    );
    if (match) {
      const tmp = L.geoJSON(match.feature);
      tmp.bindPopup(popupTable(match.feature.properties || {}, FIELDS[match.field]));
      tmp.addTo(map);
      map.fitBounds(tmp.getBounds().pad(0.25));
      tmp.openPopup();
      setTimeout(() => map.removeLayer(tmp), 5000);
    }
  }
  searchInputEl.addEventListener('change', e => doSearch(e.target.value));
  searchInputEl.addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); doSearch(e.target.value); }
  });

  document.querySelectorAll('#presets button').forEach(btn => {
    btn.addEventListener('click', () => {
      const layers = (btn.dataset.layers || '').split(',').map(s => s.trim()).filter(Boolean);
      document.querySelectorAll('input[data-layer]').forEach(cb => {
        cb.checked = layers.includes(cb.dataset.layer);
        cb.dispatchEvent(new Event('change'));
      });
      document.querySelectorAll('#eraChips .chip').forEach(chip => {
        const active = layers.includes(chip.dataset.layer);
        chip.classList.toggle('active', active);
        const layer = overlays[chip.dataset.layer];
        if (layer) {
          if (active) map.addLayer(layer); else map.removeLayer(layer);
        }
      });
      if (btn.dataset.range) {
        const [s,e] = btn.dataset.range.split('-').map(Number);
        yearStartEl.value = s;
        yearEndEl.value = e;
        filterByYear();
      }
    });
  });

  // Data last updated
  fetch(DATA + "places.geojson", { method: "HEAD" })
    .then(r => {
      const d = r.headers.get("last-modified");
      document.getElementById("updated").textContent =
        d ? `Data last updated: ${new Date(d).toLocaleString()}` : "";
    }).catch(() => {});

  // ---------- People (Person_Locations) ----------
  loadJson(DATA + "people.geojson", data => {
    const cluster = L.markerClusterGroup();
    const render = (start, end) => {
      cluster.clearLayers();
      const layer = L.geoJSON(data, {
        filter: f => {
          const y = (f.properties || {}).birth_year || (f.properties || {}).death_year;
          return !y || (y >= start && y <= end);
        },
        pointToLayer: (f, latlng) =>
          L.circleMarker(latlng, { radius: STYLE.people.radius, color: STYLE.people.color, weight: 1, fillOpacity: .85 }),
        onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.people))
      });
      cluster.addLayer(layer);
    };
    yearFilters.push(render);
    render(+yearStartEl.value, +yearEndEl.value);
    addOverlay(cluster, "People");
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'people' }));
  });

  // ---------- Places ----------
  loadJson(DATA + "places.geojson", data => {
    const layer = L.geoJSON(data, {
      pointToLayer: (f, latlng) =>
        L.circleMarker(latlng, { radius: STYLE.places.radius, color: STYLE.places.color, weight: 1, fillOpacity: .6 }),
      style: () => ({ color: STYLE.places.color, weight: 2, opacity: .8, fillOpacity: .2 }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.places))
    });
    addOverlay(layer, "Places");
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'places' }));
  });

  // ---------- Events (Event_Points) ----------
  loadJson(DATA + "events.geojson", data => {
    const layer = L.geoJSON([], {
      pointToLayer: (f, latlng) =>
        L.circleMarker(latlng, { radius: 6, color: "#b30000", weight: 1, fillOpacity: .9 }),
      style: () => ({ ...STYLE.events }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.events))
    });
    const render = (start, end) => {
      layer.clearLayers();
      const feats = (data.features || []).filter(f => {
        const y = (f.properties || {}).event_year;
        return !y || (y >= start && y <= end);
      });
      layer.addData({ type: "FeatureCollection", features: feats });
    };
    yearFilters.push(render);
    render(+yearStartEl.value, +yearEndEl.value);
    addOverlay(layer, "Events", false);
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'events' }));
  });

  // ---------- Birth / Death points ----------
  loadJson(DATA + "birth_location_points.geojson", data => {
    const layer = L.geoJSON([], {
      pointToLayer: (f, latlng) =>
        L.circleMarker(latlng, { radius: STYLE.births.radius, color: STYLE.births.color, weight: 1, fillOpacity: .9 }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.births))
    });
    const render = (start, end) => {
      layer.clearLayers();
      const feats = (data.features || []).filter(f => {
        const y = (f.properties || {}).birth_year;
        return !y || (y >= start && y <= end);
      });
      layer.addData({ type: "FeatureCollection", features: feats });
    };
    yearFilters.push(render);
    render(+yearStartEl.value, +yearEndEl.value);
    addOverlay(layer, "Birth Points");
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'births' }));
  });

  loadJson(DATA + "death_location_points.geojson", data => {
    const layer = L.geoJSON([], {
      pointToLayer: (f, latlng) =>
        L.circleMarker(latlng, { radius: STYLE.deaths.radius, color: STYLE.deaths.color, weight: 1, fillOpacity: .9 }),
      onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.deaths))
    });
    const render = (start, end) => {
      layer.clearLayers();
      const feats = (data.features || []).filter(f => {
        const y = (f.properties || {}).death_year;
        return !y || (y >= start && y <= end);
      });
      layer.addData({ type: "FeatureCollection", features: feats });
    };
    yearFilters.push(render);
    render(+yearStartEl.value, +yearEndEl.value);
    addOverlay(layer, "Death Points");
    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'deaths' }));
  });

  // ---------- Birth→Death Lines split into toggles per Era ----------
  loadJson(DATA + "birth_to_death_lines_eras.geojson", data => {
    const eras = Array.from(
      new Set((data.features || []).map(f => (f.properties || {}).era).filter(Boolean))
    ).sort();
    const lineLayers = {};
    eras.forEach(era => {
      const sub = L.geoJSON([], {
        style: () => ({ color: eraColor(era), weight: STYLE.lines.weight, opacity: STYLE.lines.opacity }),
        onEachFeature: (f, l) => l.bindPopup(popupTable(f.properties || {}, FIELDS.lines))
      });
      lineLayers[era] = sub;
      addOverlay(sub, `Lines: ${era}`);
    });
    const render = (start, end) => {
      eras.forEach(era => {
        const layer = lineLayers[era];
        layer.clearLayers();
        const feats = (data.features || []).filter(f => {
          const p = f.properties || {};
          const y = p.birth_year || p.death_year;
          return p.era === era && (!y || (y >= start && y <= end));
        });
        layer.addData({ type: "FeatureCollection", features: feats });
        layer.eachLayer(l => {
          if (l.arrowheads) l.arrowheads({ frequency: 'end', size: '15px' });
        });
      });
    };
    yearFilters.push(render);
    render(+yearStartEl.value, +yearEndEl.value);

    const chipContainer = document.getElementById('eraChips');
    eras.forEach(era => {
      const chip = document.createElement('span');
      chip.textContent = era;
      chip.className = 'chip active';
      const layerName = `Lines: ${era}`;
      chip.dataset.layer = layerName;
      chip.style.background = eraColor(era);
      chip.addEventListener('click', () => {
        chip.classList.toggle('active');
        const layer = overlays[layerName];
        if (chip.classList.contains('active')) map.addLayer(layer); else map.removeLayer(layer);
      });
      chipContainer.appendChild(chip);
    });

    const legendEl = document.getElementById("eraLegend");
    legendEl.innerHTML = "<b>Birth→Death Lines (Eras)</b>" +
      Object.entries(STYLE.eraColors)
        .map(([label, col]) => `<div><span class="swatch" style="background:${col}"></span> ${label}</div>`)
        .join("");

    (data.features || []).forEach(f => searchIndex.push({ feature: f, field: 'lines' }));
  });

  // ----- Fit map to visible layers once -----
  let fitted = false;
  function fitIfNeeded() {
    if (fitted) return;
    let bounds = null;
    for (const layer of Object.values(overlays)) {
      if (!map.hasLayer(layer)) continue;
      try {
        const b = layer.getBounds ? layer.getBounds() : L.featureGroup([layer]).getBounds();
        if (b && b.isValid()) bounds = bounds ? bounds.extend(b) : b;
      } catch {}
    }
    if (bounds && bounds.isValid()) {
      map.fitBounds(bounds.pad(0.15));
      fitted = true;
    }
  }
</script>

</body>
</html>

